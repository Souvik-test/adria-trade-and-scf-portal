// Remittance Service - Database operations for PACS.008 and PACS.009

import { supabase } from '@/integrations/supabase/client';
import { OutwardRemittanceFormData, FICreditTransferFormData } from '@/types/internationalRemittance';
import { generatePACS009FromPACS008 } from '@/utils/iso20022Generator';
import { Json } from '@/integrations/supabase/types';

export interface RemittanceTransactionRecord {
  id: string;
  user_id: string;
  transaction_ref: string;
  transfer_type: string;
  direction: string;
  status: string;
  current_stage: string;
  form_data: Json;
  created_at: string;
  updated_at: string;
  submitted_at?: string;
  approved_at?: string;
  rejected_at?: string;
  rejection_reason?: string;
}

export interface InterbankSettlementRecord {
  id: string;
  user_id: string;
  settlement_ref: string;
  parent_pacs008_id?: string;
  transfer_type: string;
  direction: string;
  status: string;
  current_stage: string;
  form_data: Json;
  created_at: string;
  updated_at: string;
  submitted_at?: string;
  approved_at?: string;
}

/**
 * Save or update a PACS.008 Customer Credit Transfer transaction
 */
export const saveRemittanceTransaction = async (
  userId: string,
  formData: OutwardRemittanceFormData,
  status: 'draft' | 'Pending Approval' | 'Approved' | 'Rejected' = 'draft',
  existingId?: string
): Promise<{ success: boolean; id?: string; transactionRef?: string; error?: string }> => {
  try {
    const { paymentHeader, orderingCustomer, beneficiaryCustomer, amountCharges, routingSettlement, regulatoryCompliance, remittanceInfo } = formData;
    
    const record = {
      user_id: userId,
      transaction_ref: '', // Auto-generated by trigger
      transfer_type: 'customer',
      direction: 'outward',
      status,
      current_stage: status === 'draft' ? 'Data Entry' : status === 'Pending Approval' ? 'Approval' : 'Completed',
      // Payment Header
      msg_ref: paymentHeader.msgRef,
      uetr: paymentHeader.uetr,
      cre_dt: paymentHeader.creDt,
      sttlm_mtd: paymentHeader.sttlmMtd,
      // Ordering Customer
      ord_name: orderingCustomer.ordName,
      ord_acct: orderingCustomer.ordAcct,
      ord_country: orderingCustomer.ordCountry,
      ord_state: orderingCustomer.ordState,
      ord_city: orderingCustomer.ordCity,
      ord_addr1: orderingCustomer.ordAddr1,
      ord_addr2: orderingCustomer.ordAddr2,
      ord_post_code: orderingCustomer.ordPostCode,
      // Beneficiary Customer
      ben_name: beneficiaryCustomer.benName,
      ben_acct: beneficiaryCustomer.benAcct,
      ben_country: beneficiaryCustomer.benCountry,
      ben_state: beneficiaryCustomer.benState,
      ben_city: beneficiaryCustomer.benCity,
      ben_addr1: beneficiaryCustomer.benAddr1,
      ben_addr2: beneficiaryCustomer.benAddr2,
      ben_post_code: beneficiaryCustomer.benPostCode,
      ben_bic: beneficiaryCustomer.benBic,
      // Amount & Charges
      inst_amt: amountCharges.instAmt || null,
      ccy: amountCharges.ccy,
      xchg_rate: amountCharges.fxRate || null,
      chg_br: amountCharges.chgBr,
      // Routing & Settlement
      instg_agt_bic: routingSettlement.instgAgtBic,
      instd_agt_bic: routingSettlement.instdAgtBic,
      intrmdy_agt_bic: routingSettlement.intrmyBic,
      // Regulatory Compliance
      purp_cd: regulatoryCompliance.purpCd,
      src_funds: regulatoryCompliance.srcFunds,
      decl_flg: regulatoryCompliance.declFlg,
      // Remittance Info
      rmt_info: remittanceInfo.rmtInfo,
      inv_ref: remittanceInfo.invRef,
      // Full form data as JSONB
      form_data: JSON.parse(JSON.stringify(formData)) as Json,
      // Timestamps
      ...(status === 'Pending Approval' ? { submitted_at: new Date().toISOString() } : {}),
      ...(status === 'Approved' ? { approved_at: new Date().toISOString() } : {}),
    };

    if (existingId) {
      // Update existing record
      const { data, error } = await supabase
        .from('remittance_transactions')
        .update(record)
        .eq('id', existingId)
        .select('id, transaction_ref')
        .single();

      if (error) throw error;
      return { success: true, id: data.id, transactionRef: data.transaction_ref };
    } else {
      // Insert new record
      const { data, error } = await supabase
        .from('remittance_transactions')
        .insert([record])
        .select('id, transaction_ref')
        .single();

      if (error) throw error;
      return { success: true, id: data.id, transactionRef: data.transaction_ref };
    }
  } catch (error: any) {
    console.error('Error saving remittance transaction:', error);
    return { success: false, error: error.message };
  }
};

/**
 * Save or update a PACS.009 FI Credit Transfer
 */
export const saveInterbankSettlement = async (
  userId: string,
  formData: FICreditTransferFormData,
  status: 'draft' | 'Pending Approval' | 'Approved' | 'Rejected' = 'draft',
  parentPacs008Id?: string,
  existingId?: string
): Promise<{ success: boolean; id?: string; settlementRef?: string; error?: string }> => {
  try {
    const { settlementHeader, instructingAgent, instructedAgent, settlementAmount, coverLinkage, settlementInstructions } = formData;
    
    const record = {
      user_id: userId,
      settlement_ref: '', // Auto-generated by trigger
      transfer_type: 'fi',
      direction: 'outward',
      status,
      current_stage: status === 'draft' ? 'Data Entry' : status === 'Pending Approval' ? 'Approval' : 'Completed',
      parent_pacs008_id: parentPacs008Id || null,
      // Settlement Header
      uetr: settlementHeader.uetr,
      cre_dt: settlementHeader.creDt,
      sttlm_mtd: settlementHeader.sttlmMtd,
      // Instructing Agent
      instg_agt_name: instructingAgent.instgAgtName,
      instg_agt_bic: instructingAgent.instgAgtBic,
      // Instructed Agent
      instd_agt_name: instructedAgent.instdAgtName,
      instd_agt_bic: instructedAgent.instdAgtBic,
      // Settlement Amount
      sttlm_amt: settlementAmount.sttlmAmt || null,
      ccy: settlementAmount.ccy,
      val_dt: settlementAmount.valDt || null,
      // Cover Linkage
      linked_pacs008_ref: coverLinkage.linkedPacs008Ref,
      linked_uetr: coverLinkage.linkedUetr,
      // Settlement Instructions
      instr_cd: settlementInstructions.instrCd,
      addtl_info: settlementInstructions.addtlInfo,
      // Full form data
      form_data: JSON.parse(JSON.stringify(formData)) as Json,
      // Timestamps
      ...(status === 'Pending Approval' ? { submitted_at: new Date().toISOString() } : {}),
      ...(status === 'Approved' ? { approved_at: new Date().toISOString() } : {}),
    };

    if (existingId) {
      const { data, error } = await supabase
        .from('interbank_settlements')
        .update(record)
        .eq('id', existingId)
        .select('id, settlement_ref')
        .single();

      if (error) throw error;
      return { success: true, id: data.id, settlementRef: data.settlement_ref };
    } else {
      const { data, error } = await supabase
        .from('interbank_settlements')
        .insert([record])
        .select('id, settlement_ref')
        .single();

      if (error) throw error;
      return { success: true, id: data.id, settlementRef: data.settlement_ref };
    }
  } catch (error: any) {
    console.error('Error saving interbank settlement:', error);
    return { success: false, error: error.message };
  }
};

/**
 * Submit PACS.008 for approval and auto-create PACS.009 if COVE settlement
 */
export const submitRemittanceForApproval = async (
  userId: string,
  formData: OutwardRemittanceFormData
): Promise<{ 
  success: boolean; 
  pacs008Id?: string; 
  pacs008Ref?: string;
  pacs009Id?: string;
  pacs009Ref?: string;
  error?: string 
}> => {
  try {
    // Save PACS.008
    const pacs008Result = await saveRemittanceTransaction(userId, formData, 'Pending Approval');
    
    if (!pacs008Result.success) {
      throw new Error(pacs008Result.error);
    }

    let pacs009Result: { id?: string; settlementRef?: string } = {};

    // If COVE settlement, auto-create PACS.009
    if (formData.paymentHeader.sttlmMtd === 'COVE') {
      const pacs009Data = generatePACS009FromPACS008(formData);
      const result = await saveInterbankSettlement(
        userId, 
        pacs009Data, 
        'Pending Approval',
        pacs008Result.id
      );

      if (result.success) {
        pacs009Result = { id: result.id, settlementRef: result.settlementRef };

        // Update PACS.008 with linked PACS.009 ID
        await supabase
          .from('remittance_transactions')
          .update({ linked_pacs009_id: result.id })
          .eq('id', pacs008Result.id);
      }
    }

    return {
      success: true,
      pacs008Id: pacs008Result.id,
      pacs008Ref: pacs008Result.transactionRef,
      pacs009Id: pacs009Result.id,
      pacs009Ref: pacs009Result.settlementRef,
    };
  } catch (error: any) {
    console.error('Error submitting remittance:', error);
    return { success: false, error: error.message };
  }
};

/**
 * Submit PACS.009 for approval
 */
export const submitFITransferForApproval = async (
  userId: string,
  formData: FICreditTransferFormData
): Promise<{ success: boolean; id?: string; settlementRef?: string; error?: string }> => {
  return saveInterbankSettlement(userId, formData, 'Pending Approval');
};

/**
 * Approve a remittance transaction
 */
export const approveRemittanceTransaction = async (
  transactionId: string,
  approverUserId: string
): Promise<{ success: boolean; error?: string }> => {
  try {
    const { error } = await supabase
      .from('remittance_transactions')
      .update({
        status: 'Approved',
        current_stage: 'Completed',
        approved_at: new Date().toISOString(),
        approved_by: approverUserId,
      })
      .eq('id', transactionId);

    if (error) throw error;
    return { success: true };
  } catch (error: any) {
    console.error('Error approving transaction:', error);
    return { success: false, error: error.message };
  }
};

/**
 * Reject a remittance transaction
 */
export const rejectRemittanceTransaction = async (
  transactionId: string,
  rejectorUserId: string,
  reason: string
): Promise<{ success: boolean; error?: string }> => {
  try {
    const { error } = await supabase
      .from('remittance_transactions')
      .update({
        status: 'Rejected',
        current_stage: 'Completed',
        rejected_at: new Date().toISOString(),
        rejected_by: rejectorUserId,
        rejection_reason: reason,
      })
      .eq('id', transactionId);

    if (error) throw error;
    return { success: true };
  } catch (error: any) {
    console.error('Error rejecting transaction:', error);
    return { success: false, error: error.message };
  }
};

/**
 * Get user's remittance transactions
 */
export const getUserRemittanceTransactions = async (
  userId: string
): Promise<{ success: boolean; data?: RemittanceTransactionRecord[]; error?: string }> => {
  try {
    const { data, error } = await supabase
      .from('remittance_transactions')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (error) throw error;
    return { success: true, data: data as unknown as RemittanceTransactionRecord[] };
  } catch (error: any) {
    console.error('Error fetching transactions:', error);
    return { success: false, error: error.message };
  }
};

/**
 * Get a single remittance transaction by ID
 */
export const getRemittanceTransaction = async (
  transactionId: string
): Promise<{ success: boolean; data?: RemittanceTransactionRecord; error?: string }> => {
  try {
    const { data, error } = await supabase
      .from('remittance_transactions')
      .select('*')
      .eq('id', transactionId)
      .single();

    if (error) throw error;
    return { success: true, data: data as unknown as RemittanceTransactionRecord };
  } catch (error: any) {
    console.error('Error fetching transaction:', error);
    return { success: false, error: error.message };
  }
};

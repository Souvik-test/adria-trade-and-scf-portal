// Remittance Service - Database operations for PACS.008 and PACS.009

import { supabase } from '@/integrations/supabase/client';
import { OutwardRemittanceFormData, FICreditTransferFormData } from '@/types/internationalRemittance';
import { generatePACS009FromPACS008 } from '@/utils/iso20022Generator';
import { Json } from '@/integrations/supabase/types';
import { customAuth } from '@/services/customAuth';

const EDGE_FUNCTION_URL = 'https://txkejzwremnrpyksizso.functions.supabase.co/submit-remittance';

export interface RemittanceTransactionRecord {
  id: string;
  user_id: string;
  transaction_ref: string;
  transfer_type: string;
  direction: string;
  status: string;
  current_stage: string;
  form_data: Json;
  created_at: string;
  updated_at: string;
  submitted_at?: string;
  approved_at?: string;
  rejected_at?: string;
  rejection_reason?: string;
}

export interface InterbankSettlementRecord {
  id: string;
  user_id: string;
  settlement_ref: string;
  parent_pacs008_id?: string;
  transfer_type: string;
  direction: string;
  status: string;
  current_stage: string;
  form_data: Json;
  created_at: string;
  updated_at: string;
  submitted_at?: string;
  approved_at?: string;
}

/**
 * Helper to check if we should use edge function (customAuth) or direct Supabase calls
 */
const shouldUseEdgeFunction = (): { useEdge: boolean; session: any } => {
  const customSession = customAuth.getSession();
  if (customSession?.access_token) {
    return { useEdge: true, session: customSession };
  }
  return { useEdge: false, session: null };
};

/**
 * Call the edge function for remittance operations
 */
const callEdgeFunction = async (
  action: string,
  payload: Record<string, unknown>
): Promise<{ success: boolean; data?: any; error?: string }> => {
  try {
    const { session } = shouldUseEdgeFunction();
    
    const response = await fetch(EDGE_FUNCTION_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': session?.access_token ? `Bearer ${session.access_token}` : '',
      },
      body: JSON.stringify({
        session,
        action,
        ...payload,
      }),
    });

    const result = await response.json();

    if (!response.ok) {
      console.error('Edge function error:', result);
      return { success: false, error: result.error || 'Failed to save transaction' };
    }

    return { success: true, data: result };
  } catch (error: any) {
    console.error('Edge function call failed:', error);
    return { success: false, error: error.message };
  }
};

/**
 * Save or update a PACS.008 Customer Credit Transfer transaction
 */
// Helper to derive channel from business application
const getChannelFromBusinessApp = (businessApp: string): string => {
  const normalized = businessApp.toLowerCase();
  if (normalized.includes('orchestrator') || normalized.includes('bank')) {
    return 'Bank';
  }
  return 'Portal';
};

export const saveRemittanceTransaction = async (
  userId: string,
  formData: OutwardRemittanceFormData,
  status: 'draft' | 'Pending Approval' | 'Approved' | 'Rejected' = 'draft',
  existingId?: string
): Promise<{ success: boolean; id?: string; transactionRef?: string; error?: string }> => {
  const { useEdge } = shouldUseEdgeFunction();
  
  // Get business application and derive channel
  const businessApplication = localStorage.getItem('businessCentre') || 'Adria TSCF Client';
  const initiatingChannel = getChannelFromBusinessApp(businessApplication);
  
  if (useEdge) {
    const action = status === 'draft' ? 'saveDraftPacs008' : 'submitPacs008';
    const result = await callEdgeFunction(action, { formData, existingId, businessApplication, initiatingChannel });
    
    if (result.success) {
      return {
        success: true,
        id: result.data.pacs008Id,
        transactionRef: result.data.pacs008Ref,
      };
    }
    return { success: false, error: result.error };
  }

  // Direct Supabase call for Supabase-authenticated users
  try {
    const { paymentHeader, orderingCustomer, beneficiaryCustomer, amountCharges, routingSettlement, regulatoryCompliance, remittanceInfo } = formData;
    
    // Get business application and derive channel for direct Supabase calls
    const businessApplication = localStorage.getItem('businessCentre') || 'Adria TSCF Client';
    const initiatingChannel = getChannelFromBusinessApp(businessApplication);
    
    const record = {
      user_id: userId,
      transaction_ref: '', // Auto-generated by trigger
      transfer_type: 'customer',
      direction: 'outward',
      status,
      current_stage: status === 'draft' ? 'Data Entry' : status === 'Pending Approval' ? 'Approval' : 'Completed',
      business_application: businessApplication,
      initiating_channel: initiatingChannel,
      // Payment Header
      msg_ref: paymentHeader.msgRef,
      uetr: paymentHeader.uetr,
      cre_dt: paymentHeader.creDt,
      sttlm_mtd: paymentHeader.sttlmMtd,
      // Ordering Customer
      ord_name: orderingCustomer.ordName,
      ord_acct: orderingCustomer.ordAcct,
      ord_country: orderingCustomer.ordCountry,
      ord_state: orderingCustomer.ordState,
      ord_city: orderingCustomer.ordCity,
      ord_addr1: orderingCustomer.ordAddr1,
      ord_addr2: orderingCustomer.ordAddr2,
      ord_post_code: orderingCustomer.ordPostCode,
      // Beneficiary Customer
      ben_name: beneficiaryCustomer.benName,
      ben_acct: beneficiaryCustomer.benAcct,
      ben_country: beneficiaryCustomer.benCountry,
      ben_state: beneficiaryCustomer.benState,
      ben_city: beneficiaryCustomer.benCity,
      ben_addr1: beneficiaryCustomer.benAddr1,
      ben_addr2: beneficiaryCustomer.benAddr2,
      ben_post_code: beneficiaryCustomer.benPostCode,
      ben_bic: beneficiaryCustomer.benBic,
      // Amount & Charges
      inst_amt: amountCharges.instAmt || null,
      ccy: amountCharges.ccy,
      xchg_rate: amountCharges.fxRate || null,
      chg_br: amountCharges.chgBr,
      // Routing & Settlement
      instg_agt_bic: routingSettlement.instgAgtBic,
      instd_agt_bic: routingSettlement.instdAgtBic,
      intrmdy_agt_bic: routingSettlement.intrmyBic,
      // Regulatory Compliance
      purp_cd: regulatoryCompliance.purpCd,
      src_funds: regulatoryCompliance.srcFunds,
      decl_flg: regulatoryCompliance.declFlg,
      // Remittance Info
      rmt_info: remittanceInfo.rmtInfo,
      inv_ref: remittanceInfo.invRef,
      // Full form data as JSONB
      form_data: JSON.parse(JSON.stringify(formData)) as Json,
      // Timestamps
      ...(status === 'Pending Approval' ? { submitted_at: new Date().toISOString() } : {}),
      ...(status === 'Approved' ? { approved_at: new Date().toISOString() } : {}),
    };

    if (existingId) {
      const { data, error } = await supabase
        .from('remittance_transactions')
        .update(record)
        .eq('id', existingId)
        .select('id, transaction_ref')
        .single();

      if (error) throw error;
      return { success: true, id: data.id, transactionRef: data.transaction_ref };
    } else {
      const { data, error } = await supabase
        .from('remittance_transactions')
        .insert([record])
        .select('id, transaction_ref')
        .single();

      if (error) throw error;
      return { success: true, id: data.id, transactionRef: data.transaction_ref };
    }
  } catch (error: any) {
    console.error('Error saving remittance transaction:', error);
    return { success: false, error: error.message };
  }
};

/**
 * Save or update a PACS.009 FI Credit Transfer
 */
export const saveInterbankSettlement = async (
  userId: string,
  formData: FICreditTransferFormData,
  status: 'draft' | 'Pending Approval' | 'Approved' | 'Rejected' = 'draft',
  parentPacs008Id?: string,
  existingId?: string
): Promise<{ success: boolean; id?: string; settlementRef?: string; error?: string }> => {
  const { useEdge } = shouldUseEdgeFunction();
  
  // Get business application and derive channel
  const businessApplication = localStorage.getItem('businessCentre') || 'Adria TSCF Client';
  const initiatingChannel = getChannelFromBusinessApp(businessApplication);
  
  if (useEdge) {
    const action = status === 'draft' ? 'saveDraftPacs009' : 'submitPacs009';
    const result = await callEdgeFunction(action, { formData, parentPacs008Id, existingId, businessApplication, initiatingChannel });
    
    if (result.success) {
      return {
        success: true,
        id: result.data.id,
        settlementRef: result.data.settlementRef,
      };
    }
    return { success: false, error: result.error };
  }

  // Direct Supabase call for Supabase-authenticated users
  try {
    const { settlementHeader, instructingAgent, instructedAgent, settlementAmount, coverLinkage, settlementInstructions } = formData;
    
    const record = {
      user_id: userId,
      settlement_ref: '', // Auto-generated by trigger
      transfer_type: 'fi',
      direction: 'outward',
      status,
      current_stage: status === 'draft' ? 'Data Entry' : status === 'Pending Approval' ? 'Approval' : 'Completed',
      parent_pacs008_id: parentPacs008Id || null,
      business_application: businessApplication,
      initiating_channel: initiatingChannel,
      // Settlement Header
      uetr: settlementHeader.uetr,
      cre_dt: settlementHeader.creDt,
      sttlm_mtd: settlementHeader.sttlmMtd,
      // Instructing Agent
      instg_agt_name: instructingAgent.instgAgtName,
      instg_agt_bic: instructingAgent.instgAgtBic,
      // Instructed Agent
      instd_agt_name: instructedAgent.instdAgtName,
      instd_agt_bic: instructedAgent.instdAgtBic,
      // Settlement Amount
      sttlm_amt: settlementAmount.sttlmAmt || null,
      ccy: settlementAmount.ccy,
      val_dt: settlementAmount.valDt || null,
      // Cover Linkage
      linked_pacs008_ref: coverLinkage.linkedPacs008Ref,
      linked_uetr: coverLinkage.linkedUetr,
      // Settlement Instructions
      instr_cd: settlementInstructions.instrCd,
      addtl_info: settlementInstructions.addtlInfo,
      // Full form data
      form_data: JSON.parse(JSON.stringify(formData)) as Json,
      // Timestamps
      ...(status === 'Pending Approval' ? { submitted_at: new Date().toISOString() } : {}),
      ...(status === 'Approved' ? { approved_at: new Date().toISOString() } : {}),
    };

    if (existingId) {
      const { data, error } = await supabase
        .from('interbank_settlements')
        .update(record)
        .eq('id', existingId)
        .select('id, settlement_ref')
        .single();

      if (error) throw error;
      return { success: true, id: data.id, settlementRef: data.settlement_ref };
    } else {
      const { data, error } = await supabase
        .from('interbank_settlements')
        .insert([record])
        .select('id, settlement_ref')
        .single();

      if (error) throw error;
      return { success: true, id: data.id, settlementRef: data.settlement_ref };
    }
  } catch (error: any) {
    console.error('Error saving interbank settlement:', error);
    return { success: false, error: error.message };
  }
};

/**
 * Submit PACS.008 for approval and auto-create PACS.009 if COVE settlement
 */
export const submitRemittanceForApproval = async (
  userId: string,
  formData: OutwardRemittanceFormData
): Promise<{ 
  success: boolean; 
  pacs008Id?: string; 
  pacs008Ref?: string;
  pacs009Id?: string;
  pacs009Ref?: string;
  error?: string 
}> => {
  const { useEdge } = shouldUseEdgeFunction();
  
  if (useEdge) {
    // Edge function handles everything including auto-creating PACS.009 for COVE
    const result = await callEdgeFunction('submitPacs008', { formData });
    
    if (result.success) {
      return {
        success: true,
        pacs008Id: result.data.pacs008Id,
        pacs008Ref: result.data.pacs008Ref,
        pacs009Id: result.data.pacs009Id,
        pacs009Ref: result.data.pacs009Ref,
      };
    }
    return { success: false, error: result.error };
  }

  // Direct Supabase call for Supabase-authenticated users
  try {
    const pacs008Result = await saveRemittanceTransaction(userId, formData, 'Pending Approval');
    
    if (!pacs008Result.success) {
      throw new Error(pacs008Result.error);
    }

    let pacs009Result: { id?: string; settlementRef?: string } = {};

    // If COVE settlement, auto-create PACS.009
    if (formData.paymentHeader.sttlmMtd === 'COVE') {
      const pacs009Data = generatePACS009FromPACS008(formData);
      const result = await saveInterbankSettlement(
        userId, 
        pacs009Data, 
        'Pending Approval',
        pacs008Result.id
      );

      if (result.success) {
        pacs009Result = { id: result.id, settlementRef: result.settlementRef };

        // Update PACS.008 with linked PACS.009 ID
        await supabase
          .from('remittance_transactions')
          .update({ linked_pacs009_id: result.id })
          .eq('id', pacs008Result.id);
      }
    }

    return {
      success: true,
      pacs008Id: pacs008Result.id,
      pacs008Ref: pacs008Result.transactionRef,
      pacs009Id: pacs009Result.id,
      pacs009Ref: pacs009Result.settlementRef,
    };
  } catch (error: any) {
    console.error('Error submitting remittance:', error);
    return { success: false, error: error.message };
  }
};

/**
 * Submit PACS.009 for approval
 */
export const submitFITransferForApproval = async (
  userId: string,
  formData: FICreditTransferFormData
): Promise<{ success: boolean; id?: string; settlementRef?: string; error?: string }> => {
  return saveInterbankSettlement(userId, formData, 'Pending Approval');
};

/**
 * Approve a remittance transaction
 */
export const approveRemittanceTransaction = async (
  transactionId: string,
  approverUserId: string
): Promise<{ success: boolean; error?: string }> => {
  const { useEdge } = shouldUseEdgeFunction();
  
  if (useEdge) {
    const result = await callEdgeFunction('approve', { transactionId });
    return { success: result.success, error: result.error };
  }

  try {
    const { error } = await supabase
      .from('remittance_transactions')
      .update({
        status: 'Approved',
        current_stage: 'Completed',
        approved_at: new Date().toISOString(),
        approved_by: approverUserId,
      })
      .eq('id', transactionId);

    if (error) throw error;
    return { success: true };
  } catch (error: any) {
    console.error('Error approving transaction:', error);
    return { success: false, error: error.message };
  }
};

/**
 * Reject a remittance transaction
 */
export const rejectRemittanceTransaction = async (
  transactionId: string,
  rejectorUserId: string,
  reason: string
): Promise<{ success: boolean; error?: string }> => {
  const { useEdge } = shouldUseEdgeFunction();
  
  if (useEdge) {
    const result = await callEdgeFunction('reject', { transactionId, reason });
    return { success: result.success, error: result.error };
  }

  try {
    const { error } = await supabase
      .from('remittance_transactions')
      .update({
        status: 'Rejected',
        current_stage: 'Completed',
        rejected_at: new Date().toISOString(),
        rejected_by: rejectorUserId,
        rejection_reason: reason,
      })
      .eq('id', transactionId);

    if (error) throw error;
    return { success: true };
  } catch (error: any) {
    console.error('Error rejecting transaction:', error);
    return { success: false, error: error.message };
  }
};

/**
 * Get user's remittance transactions
 */
export const getUserRemittanceTransactions = async (
  userId: string
): Promise<{ success: boolean; data?: RemittanceTransactionRecord[]; error?: string }> => {
  try {
    const { data, error } = await supabase
      .from('remittance_transactions')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (error) throw error;
    return { success: true, data: data as unknown as RemittanceTransactionRecord[] };
  } catch (error: any) {
    console.error('Error fetching transactions:', error);
    return { success: false, error: error.message };
  }
};

/**
 * Get a single remittance transaction by ID
 */
export const getRemittanceTransaction = async (
  transactionId: string
): Promise<{ success: boolean; data?: RemittanceTransactionRecord; error?: string }> => {
  try {
    const { data, error } = await supabase
      .from('remittance_transactions')
      .select('*')
      .eq('id', transactionId)
      .single();

    if (error) throw error;
    return { success: true, data: data as unknown as RemittanceTransactionRecord };
  } catch (error: any) {
    console.error('Error fetching transaction:', error);
    return { success: false, error: error.message };
  }
};
